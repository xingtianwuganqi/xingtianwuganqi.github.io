<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS cell的复用问题及解决办法]]></title>
    <url>%2F2020%2F04%2F06%2FiOS%20cell%E7%9A%84%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[UITableView中单元格复用有两种方法,dequeueReusableCell与dequeueReusableCell:indexPath. 12345// 1open func dequeueReusableCell(withIdentifier identifier: String) -&gt; UITableViewCell? // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.// 2@available(iOS 6.0, *)open func dequeueReusableCell(withIdentifier identifier: String, for indexPath: IndexPath) -&gt; UITableViewCell // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 这两个方法的区别1.方法1返回的cell是一个含有这个重用标识符的无效cell,这个cell没有初始化，需要在下面判断cell是否是空，是空就初始化 1234var cell:UITableViewCell? = tableView.dequeueReusableCell(withIdentifier: &quot;CustomTableCell&quot;)if cell == nil &#123; cell = UITableViewCell.init(style: .default, reuseIdentifier: &quot;CustomTableCell&quot;)&#125; 2.方法2总是返回一个有效的cell，需要提前注册 123self.tableView.register(UINib.init(nibName: &quot;CustomTableCell&quot;, bundle:.main), forCellReuseIdentifier: &quot;CustomTableCell&quot;)let cell:UITableViewCell = tableView.dequeueReusableCell(withIdentifier: &quot;CustomTableCell&quot;, for: indexPath) 出现cell复用的问题时：1.可以给每个cell不同的标识符 12345let identifier = &quot;\(indexPath.row).indentifier&quot;var cell:UITableViewCell? = tableView.dequeueReusableCell(withIdentifier: indentifierif cell == nil &#123; cell = UITableViewCell.init(style: .default, reuseIdentifier: indentifier)&#125; 2.不设置重用标识符创建cell 1234var cell:UITableViewCell? = tableView.cellForRow(at: indexPath)if cell == nil &#123; cell = UITableViewCell.init(style: .default, reuseIdentifier: indentifier)&#125;]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建私有cocoaPods库及遇到的问题]]></title>
    <url>%2F2020%2F03%2F03%2F%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89cocoaPods%E5%BA%93%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1 .创建远端（github/gitlab）仓库 例如：创建-&gt;projectMain作为项目主功能仓库，创建-&gt;project_login为后期引用的（登录）组件化工程。创建-&gt;project_SDK为后期引用的（基础组件SDK）组件化工程。创建-&gt;project_Repo为版本管理仓库。。等等 2.创建本地仓库 例如：新建桌面文件A文件（如有多级仓库可在A文件下创建子文件a文件、b文件、c文件等） 3.将远端URL仓库克隆至本地:12345#关键代码git clone http://xxxx.gittipscd 至A文件执行克隆，如：git clone http://project_login.git 4. 创建podspec文件（描述pod库版本文件）: pod spec create 工程名称 如：进入步骤3中克隆的项目文件，在隐藏文件.git同级执行：pod spec create project_login12tipspod spec create project_login 5.配置spec（描述pod库版本文件）:直接XCode打开或者文本编译器打开123456789101112131415161718192021Pod::Spec.new do |spec| spec.name = &quot;project_login&quot; spec.version = &quot;1.0.2&quot; spec.summary = &quot;project_login.&quot; spec.description = &lt;&lt;-DESC project_login DESC spec.homepage = &quot;http://192.168.65.252/jingjun/project_login.git&quot; spec.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125; spec.swift_version = &apos;4.0&apos; spec.author = &#123; &quot;jingjun&quot; =&gt; &quot;254032134@qq.com&quot; &#125; spec.platform = :ios, &quot;10.0&quot; spec.source = &#123; :git =&gt; &quot;http://192.168.65.252/jingjun/project_login.git&quot;, :tag =&gt; &quot;#&#123;spec.version&#125;&quot; &#125; spec.source_files = &quot;project_name/swiftText/*.&#123;swift&#125;&quot; spec.frameworks = &quot;Foundation&quot;,&quot;UIKit&quot; #spec.ios.dependency &quot;SDWebImage&quot; spec.ios.dependency &quot;SnapKit&quot; spec.ios.dependency &quot;RxSwift&quot;end 备注版： 123456789101112131415161718192021222324252627282930#项目中有很多配置，下面仅书写必要的几个（一定注意配置正确）：#下面`spec`有的直接写是`s` 注意上下对应Pod::Spec.new do |spec|#项目名称一般与创建的远端仓库名字一致spec.name = &quot;mPaaS_Login&quot;#对应版本号（所有代码但凡改动就需要修改版本号：最大保持四位数：1.0.0.0）spec.version = &quot;1.0.0&quot;#简单描述spec.summary = &quot;A short description of mPaaS_Login.&quot;#简单功能描述：一定注意`&lt;&lt;-DESC` 在第一行，描述内容另起一行 ，最后`DESC`一行包裹spec.description = &lt;&lt;-DESCloginDESC#文件页可随意写一般写仓库链接spec.homepage = &quot;http://192.168.66.56:9080/iOS_HF/mPaaS_Login.git&quot;#协议spec.license = &#123; :type =&gt; &quot;MIT&quot; &#125;#作者（版权）spec.author = &quot;ws&quot;#支持平台版本 如还支持其他平台可百度拓展spec.platform = :ios, &quot;8.0&quot;#项目源文件地址 远端仓库地址spec.source = &#123; :git =&gt; &quot;http://192.168.66.56:9080/iOS_HF/mPaaS_Login.git&quot;, :tag =&gt; &quot;#&#123;spec.version&#125;&quot; &#125;#仓库暴露的一些文件，如有引用其他动态库、静态库百度拓展spec.ios.source_files = &quot;HF_NHBankA/HF_NHBankA/Sources/**/*.&#123;h,m,mm&#125;&quot;#添加依赖 如有依赖下面检测合法性记得加上文件源spec.ios.dependency &quot;HF_mPaaSSDK&quot;#收尾end source_files 极易写错，注意是从project_login.podspec同级文件夹开始，一层一层写1234// 如果swiftText文件下就是.swift文件就在swiftText后面写/*spec.source_files = &quot;project_name/swiftText/*.&#123;swift&#125;&quot; // 如果swiftText文件下还有文件夹，可以写成spec.source_files = &quot;project_name/swiftText/**/*.&#123;h,m,swift&#125;&quot; 6. 检测sepc文件配置是否正确:pod lib lint –allow-warnings1234567891011pod lib lint是只从本地验证你的pod能否通过验证pod spec lint是从本地和远程验证你的pod能否通过验证`--allow-warnings`意思是忽略警告，一般都加，如有报错，针对错误问题修改配置文件，如配置文件确认无误，并提示编译问题可按照： ([https://www.jianshu.com/p/88180b4d2ab7](https://www.jianshu.com/p/88180b4d2ab7))文章配置.。无误后继续`步骤7`#万能检测命令：sources 为对应版本管理库地址pod lib lint --allow-warnings --sources=http://192.168.66.56:9080/iOS_HF/mPaaS_Repo.git --use-libraries --skip-import-validation --verbose#万能检测命令：sources 为对应版本管理库地址pod lib lint --allow-warnings --sources=http://192.168.66.56:9080/iOS_HFAPP/HFmPaaS_Repo.git --use-libraries --skip-import-validation --verbose 7. 提交代码至远端仓库1234567891011#添加文件git add .#提交添加描述git commit -m &quot;描述&quot;#推送至远端仓库git push#打tag标签,与`步骤5`中spec文件版本保持一致git tag 1.0.0#推送本次所打的所有tag标签到远程origin。git push --tags// 注意.podspec 中的文件.version 和 tag 相同 8. （首次）将本地私有仓库与远程管理库连接 :pod repo add 版本管理仓库名 远端版本管理仓库地址url.git12#关联版本仓库pod repo add project_login &apos;http://192.168.65.252/jingjun/project_login.git&apos; 9. 将spec文件推送到远程管理库 : pod repo push 版本管理仓库名 组件库名.podspec –use-libraries –allow-warnings –verbose1234pod repo push project_login project_login.podspec --use-libraries --allow-warnings --verbose#万能推送命令(需改成自己的文件名称)：project_login project_login.podspec --sources=&apos;http://192.168.65.252/jingjun/project_login.git,https://github.com/CocoaPods/Specs.git&apos; --use-libraries --skip-import-validation --verbose --allow-warnings 10.引用私有库在主项目里Podfile文件里添加需要引用私有源地址:1234source &apos;http://192.168.65.252/jingjun/project_login.git&apos; source &apos;https://github.com/CocoaPods/Specs.git&apos;pod &apos;project_login&apos;,:git =&gt; &apos;http://192.168.65.252/jingjun/project_login.git&apos; 遇到的问题1）Encountered an unknown error (Unable to find a specification for xxxx depended upon by xxxx// 给–sources 赋值的时候，一定也要带上官方的源。 官方的源：https://github.com/CocoaPods/Specs.git1pod repo push project_login project_login.podspec --sources=&apos;http://192.168.65.252/jingjun/project_login.git,https://github.com/CocoaPods/Specs.git&apos; --use-libraries --skip-import-validation --verbose --allow-warnings 2）[!] The project_login.podspec specification does not validate. .podspec文件存在警告时不能成功push。加 –allow-warnings 12// 在后面加上 --allow-warningspod repo push project_login project_login.podspec --sources=&apos;http://192.168.65.252/jingjun/project_login.git,https://github.com/CocoaPods/Specs.git&apos; --use-libraries --skip-import-validation --verbose --allow-warnings 3）ERROR | [iOS] unknown: Encountered an unknown error (Unable to find a specification for RxSwift depended upon by RxSwiftExt/Core12345678910// 首先在.podspec 文件中加spec.ios.dependency &quot;SnapKit&quot;spec.ios.dependency &quot;RxSwift&quot;// 再在项目的podfile 文件中加入source &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;http://192.168.65.252/jingjun/project_login.git&apos;// 然后调用命令pod repo push project_login project_login.podspec --sources=&apos;http://192.168.65.252/jingjun/project_login.git,https://github.com/CocoaPods/Specs.git&apos; --use-libraries --skip-import-validation --verbose --allow-warnings 4）ERROR | [iOS] unknown: Encountered an unknown error (Pod::DSLError) during validation 一般是.podspec 文件格式有问题，检测是否错误输入 ####5）[!] CocoaPods could not find compatible versions for pod “PLMediaStreamingKit”: In Podfile: PLMediaStreamingKit (~&gt; 2.3.2)Specs satisfying the PLMediaStreamingKit (~&gt; 2.3.2) dependency were found, but they required a higher minimum deployment target.1spec.platform 的iOS版本要与主文件中 platform :ios , &apos;7.0&apos;，的版本一致]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 实现列表下拉顶部图片放大]]></title>
    <url>%2F2020%2F01%2F13%2FiOS%20%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E4%B8%8B%E6%8B%89%E9%A1%B6%E9%83%A8%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[实现思路tableview 下拉中露出的tableview背景时，动态设置顶部的图片高度，使用图片盖住露出的tableview背景 demo地址 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import UIKitimport RxSwiftlet ScreenW = UIScreen.main.bounds.size.widthlet statusBarH = UIApplication.shared.statusBarFrame.size.heightclass AccountHeaderView: UIView &#123; var disposeBag = DisposeBag() lazy var panoView : UIImageView = &#123; let imgView = UIImageView() imgView.image = UIImage(named: &quot;avator&quot;) imgView.contentMode = .scaleAspectFill imgView.clipsToBounds = true return imgView &#125;() var bgImgFrame: CGRect // 展示其他信息 var infoView: UIView? lazy var backPanoView : UIView = &#123; let view = UIView() return view &#125;() override init(frame:CGRect) &#123; self.bgImgFrame = CGRect(x: 0, y: 0, width: ScreenW, height: 200) super.init(frame: frame) self.addSubview(backPanoView) self.backPanoView.addSubview(panoView) // 展示其他信息 self.infoView = UIView() self.addSubview(infoView!) self.backPanoView.frame = self.bgImgFrame &#125; override func layoutSubviews() &#123; super.layoutSubviews() self.panoView.snp.makeConstraints &#123; (make) in make.edges.equalToSuperview() &#125; self.infoView?.snp.makeConstraints &#123; (make) in make.top.equalToSuperview().offset(200) make.left.right.equalToSuperview() make.bottom.equalToSuperview() &#125; &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func scrollVieDidScroll(offsetY: CGFloat) &#123; // 在tableview滑动过程中重新这只backPanoView 的frame if offsetY &lt;= 0&#123; var rect = self.backPanoView.frame rect.origin.y = offsetY rect.size.height = 200 - offsetY self.backPanoView.frame = rect self.panoView.setNeedsLayout() &#125; &#125;&#125;]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 仿微信朋友圈实现图片点击放大查看]]></title>
    <url>%2F2019%2F12%2F09%2FSwift%20%E4%BB%BF%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%82%B9%E5%87%BB%E6%94%BE%E5%A4%A7%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[实现思路scrollView 具有放大缩小的功能，实现图片的放大与缩小的思路就是将imageView放在scrollView上，双击时调用scrollView的12@available(iOS 3.0, *) open func zoom(to rect: CGRect, animated: Bool) 来实现imageView的放大与缩小 Demo地址 效果图： 实现步骤1.两个初始化方法123456// 通过图片url数组初始化init(urlArr: [String],number: Int)// 通过图片数组初始化init(_ Images: [UIImage],number: Int) 在初始化方法中初始化backScrollView 和承载imageView的scrollView,并给imageView和scrollView添加点击手势 2.承载imageView的scrollView设置代理方法12345678910111213141516171819202122232425262728293031extension ShowBigImgView : UIScrollViewDelegate &#123; // 当scrollview 尝试进行缩放的时候 func viewForZooming(in scrollView: UIScrollView) -&gt; UIView? &#123; let offsetX = self.backScroll.contentOffset.x let tagValue = offsetX / ScreenW return self.backScroll.viewWithTag(Int(tagValue))?.viewWithTag(100 + Int(tagValue)) &#125; // 当缩放完毕的时候调用 func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) &#123; printLog(message: &quot;缩放结束-\(scale)&quot;) &#125; // 当正在缩放的时候 func scrollViewDidZoom(_ scrollView: UIScrollView) &#123; printLog(message: &quot;正在缩放&quot;) let offsetX = self.backScroll.contentOffset.x let tagValue = offsetX / ScreenW //获取到这个scrollview var centerX = self.backScroll.center.x var centerY = self.backScroll.center.y centerX = scrollView.contentSize.width &gt; scrollView.frame.size.width ? scrollView.contentSize.width/2:centerX centerY = scrollView.contentSize.height &gt; scrollView.frame.size.height ? scrollView.contentSize.height/2:centerY scrollView.viewWithTag(100 + Int(tagValue))?.center = CGPoint(x: centerX, y: centerY) &#125;&#125; 3.图片的点击放大手势123456789101112131415161718192021222324252627 @objc func imageClick(tap:UITapGestureRecognizer) &#123; var newscale : CGFloat = 0 guard let scroll = tap.view?.superview as? UIScrollView else &#123; return &#125; if scroll.zoomScale == 1.0 &#123; newscale = 3 &#125;else &#123; newscale = 1.0 &#125; let zoomRect = self.zoomRectForScale(scrollview: scroll,scale: newscale, center: tap.location(in: tap.view)) scroll.zoom(to: zoomRect, animated: true) &#125;// 计算放大或缩小的frame func zoomRectForScale(scrollview: UIScrollView, scale: CGFloat,center: CGPoint) -&gt; CGRect &#123; var zoomRect: CGRect = CGRect() zoomRect.size.height = scrollview.frame.size.height / scale zoomRect.size.width = scrollview.frame.size.width / scale zoomRect.origin.x = center.x - (zoomRect.size.width / 2.0) zoomRect.origin.y = center.y - (zoomRect.size.height / 2.0) return zoomRect &#125; 4.出现时的动画123456789101112131415161718 func pushAnimation(num: Int) &#123; // 获取UIImageView() guard let imageView = self.backScroll.viewWithTag(100 + num) as? UIImageView else &#123; return &#125; transformAnimation(animationView: imageView) &#125;// 缩放动画 func transformAnimation(animationView: UIImageView) &#123; let animation: CABasicAnimation = CABasicAnimation() animation.keyPath = &quot;transform.scale&quot; animation.fromValue = 0.2 // 原始系数 animation.toValue = 1 // 缩放系数 animation.duration = 0.3 animation.isRemovedOnCompletion = true animation.fillMode = kCAFillModeRemoved animationView.layer.add(animation, forKey: nil) &#125; 5.消失时的动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 @objc func backBtnClick() &#123; self.removeAnimation() DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) &#123; self.removeFromSuperview() &#125; &#125;// 缩放 + 淡入淡出 func removeAnimation() &#123; let x = Int(self.backScroll.contentOffset.x) let y = Int(ScreenW) guard (x % y) == 0 else&#123; return &#125; // 获取 let tag = x / y + 100 guard let imageView = self.backScroll.viewWithTag(tag) else &#123; return &#125; let scale = CABasicAnimation() scale.keyPath = &quot;transform.scale&quot; scale.fromValue = 1.0 scale.toValue = 0.2 scale.duration = 0.3 scale.fillMode = kCAFillModeForwards scale.isRemovedOnCompletion = false imageView.layer.add(scale, forKey: nil) let backAnimation = CAKeyframeAnimation() backAnimation.keyPath = &quot;opacity&quot; backAnimation.duration = 0.4 backAnimation.values = [ NSNumber(value: 0.90 as Float), NSNumber(value: 0.60 as Float), NSNumber(value: 0.30 as Float), NSNumber(value: 0.0 as Float), ] backAnimation.keyTimes = [ NSNumber(value: 0.1), NSNumber(value: 0.2), NSNumber(value: 0.3), NSNumber(value: 0.4) ] backAnimation.fillMode = kCAFillModeForwards backAnimation.isRemovedOnCompletion = false self.layer.add(backAnimation, forKey: nil) &#125; 6.调用12345678910111213func showImg (imgs: [String],url: String) &#123; var number = 0 //获取当前图片的下标 _ = imgs.enumerated().map &#123; (index,urlStr) in if urlStr == url &#123; number = index &#125; &#125; let show = ShowBigImgView(urlArr: imgs,number: number) UIApplication.shared.keyWindow?.addSubview(show) // 缩放动画 show.pushAnimation(num: number) &#125; Demo地址]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 简单的圆形进度条]]></title>
    <url>%2F2019%2F09%2F15%2FSwift%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[下载时的圆形进度条示例图： 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import UIKitfunc degreesToRadians(x:CGFloat) -&gt; CGFloat&#123; return CGFloat(double_t.pi) * (x) / 180.0&#125;let ProgressDownload = 1class NewsYBDownLoadVIew: UIView &#123; var _trackLayer:CAShapeLayer? var _progressLayer:CAShapeLayer? private var progress:CGFloat = 0 //中间叉的图片 private let cancelImg : UIImageView = &#123; let image = UIImageView() image.image = UIImage(named: &quot;news_yb_cancel_down&quot;) return image &#125;() // 在合适的位置设计setprogress 属性即可 var setprogress:CGFloat = 0&#123; willSet &#123; changeProgress(progress: newValue) &#125; &#125; override func draw(_ rect: CGRect) &#123; // Drawing code //创建一个track shape layer _trackLayer = CAShapeLayer() _trackLayer?.frame = self.bounds _trackLayer?.fillColor = UIColor.clear.cgColor _trackLayer?.strokeColor = UIColor(hexString: &quot;#a6a6a6&quot;)!.cgColor self.layer.addSublayer(_trackLayer!) // _trackLayer?.opacity = 1 //背景透明度 _trackLayer?.lineCap = CAShapeLayerLineCap.round //指定线的边缘是园的 _trackLayer?.lineWidth = CGFloat(ProgressDownload) //线的宽度 /* center：圆心的坐标 radius：半径 startAngle：起始的弧度 endAngle：圆弧结束的弧度 clockwise：true为顺时针，false为逆时针 方法里面主要是理解startAngle与endAngle */ let path = UIBezierPath.init(arcCenter: CGPoint(x:self.frame.size.width/2,y:(self.frame.height/2)), radius: self.frame.width/2, startAngle: degreesToRadians(x: -90), endAngle: degreesToRadians(x: 270), clockwise: true) _trackLayer?.path = path.cgPath // 把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。 _progressLayer = CAShapeLayer() _progressLayer?.frame = self.bounds _progressLayer?.fillColor = UIColor.clear.cgColor _progressLayer?.strokeColor = UIColor(hexString: &quot;#FFB644&quot;)!.cgColor _progressLayer?.lineCap = CAShapeLayerLineCap.round _progressLayer?.lineWidth = CGFloat(ProgressDownload) _progressLayer?.path = path.cgPath _progressLayer?.opacity = 1 _progressLayer?.strokeEnd = 0 self.layer.addSublayer(_progressLayer!) &#125; override init(frame: CGRect) &#123; super.init(frame: frame) self.backgroundColor = UIColor.white self.setUpSubViews() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func setUpSubViews()&#123; self.addSubview(cancelImg) cancelImg.frame = CGRect(x: 5, y: 5, width: 9, height: 9) &#125; func changeProgress(progress: CGFloat) &#123; self.progress = progress _progressLayer?.strokeEnd = self.progress &#125; &#125;]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取相册中的视频列表]]></title>
    <url>%2F2019%2F08%2F07%2FiOS%20%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%86%8C%E4%B8%AD%E7%9A%84%E8%A7%86%E9%A2%91%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[获取相册中的视频文件123456789101112131415161718192021222324func getAllvideo() &#123; let cameraRolls = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumVideos, options: nil) print(cameraRolls) guard cameraRolls.count &gt; 0 else &#123; return &#125; for i in 0 ..&lt; cameraRolls.count &#123; let albumCollection = cameraRolls[i] // 获取相簿(albumCollection)下所有PHAsset对象并存储在集合albumAssets中 LOGGER.debug(albumCollection.localizedTitle) let albumAssets = PHAsset.fetchAssets(in: albumCollection, options: nil) for i in 0 ..&lt; albumAssets.count &#123; let asset = albumAssets[i] let filetype = asset.mediaType if filetype == PHAssetMediaType.video &#123; videoMessage(asset: asset,count: albumAssets.count) &#125; continue &#125; &#125; &#125; 获取视频信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 获取PHAsset 对象的信息 func videoMessage(asset: PHAsset , count: Int) &#123; let options = PHVideoRequestOptions() options.version = .current options.deliveryMode = .automatic options.isNetworkAccessAllowed = true // 获取iCloud 中的视频 var iconImage = UIImage() let option = PHImageRequestOptions() option.resizeMode = PHImageRequestOptionsResizeMode.fast // 获取视频对于的图片 PHImageManager.default().requestImage(for: asset, targetSize: CGSize(width: 116, height: 78), contentMode: PHImageContentMode.default, options: option) &#123; (image, info) in if let img = image &#123; iconImage = img &#125; &#125; PHImageManager.default().requestAVAsset(forVideo: asset, options: options) &#123; [weak self](asset, audioMix, info) in LOGGER.debug(asset) LOGGER.debug(audioMix) LOGGER.debug(info) guard let ass = asset else &#123; return &#125; guard let url = ass as? AVURLAsset else &#123; return &#125; var size : Float = 0 do &#123; let si = try url.url.resourceValues(forKeys: [URLResourceKey.fileSizeKey]) size = Float(si.fileSize ?? 0) / (1024.0*1024.0) &#125;catch &#123; &#125; // 计算时长 let time = ass.duration let seconds = ceil(Float(time.value)/Float(time.timescale)) let minute = String(format: &quot;%ld&quot;, Int(floor(seconds / 60))) let second = String(format: &quot;%.2ld&quot;, Int(seconds) % 60) let times = &quot;\(minute):\(second)&quot; //获取拍摄时间 let date = ass.creationDate?.dateValue let dataFormat = DateFormatter() dataFormat.dateFormat = &quot;yyyy:MM:dd HH:mm:ss&quot; let cDate = dataFormat.string(from: date ?? Date(timeIntervalSinceNow: 0)) let name = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).first ?? &quot;&quot; let format = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).last ?? &quot;&quot; let videoinfo = videoInfo(image: iconImage, name: name, time: times, urlStr: url.url.absoluteString, length: times, selected: false, date: cDate, size: size, second: String(format: &quot;%.0f&quot;, seconds),format: format) // 一定要在主线程中加入到数组，不然会出现崩溃 DispatchQueue.main.async &#123; self?.videoArr.append(videoinfo) self?._mainTableView.reloadData() &#125; &#125; &#125; 在测试中，上述方法可以获取相册视频的文件地址，但是在部分手机上，将文件地址转换成data上传到服务器时出错了1234567891011121314151617181920let data : Data do &#123; data = try Data.init(contentsOf: URL.init(string: path)) manager?.put(data, key: key, token: token, complete: &#123; [weak self](info, key, resp) in &#125;, option: options) &#125;catch let error &#123; // 这里报错，打印出来是 /* Error Domain=NSCocoaErrorDomain Code=257 &quot;The file “IMG_0288.MP4” couldn’t be\ opened because you don’t have permission to view it.&quot; UserInfo= &#123;NSFilePath=/var/mobile/Media/DCIM/100APPLE/IMG_0288.MP4, NSUnderlyingError=0x17d761b0 &#123;Error Domain=NSPOSIXErrorDomain Code=1 &quot;Operation not permitted&quot;&#125;&#125; */ print(error) LOGGER.debug(&quot;filepath 转 data 失败&quot;) HUDUtilInstance.showHUD(message: &quot;获取视频失败&quot;) &#125; 通过查资料https://io.upyun.com/2016/03/23/the-real-files-in-alasset-and-phasset/代码调整为 获取相册中的视频文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func getAllvideo() &#123; let cameraRolls = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumVideos, options: nil) print(cameraRolls) guard cameraRolls.count &gt; 0 else &#123; return &#125; for i in 0 ..&lt; cameraRolls.count &#123; let albumCollection = cameraRolls[i] // 获取相簿(albumCollection)下所有PHAsset对象并存储在集合albumAssets中 LOGGER.debug(albumCollection.localizedTitle) let albumAssets = PHAsset.fetchAssets(in: albumCollection, options: nil) for i in 0 ..&lt; albumAssets.count &#123; let asset = albumAssets[i] let filetype = asset.mediaType // if filetype == PHAssetMediaType.video &#123; // videoMessage(asset: asset,count: albumAssets.count) // &#125; if filetype == PHAssetMediaType.video &#123; // 通过asset 获取视频 let assetResources = PHAssetResource.assetResources(for: asset) var resources : PHAssetResource? for assetRes in assetResources &#123; if #available(iOS 9.1, *) &#123; if assetRes.type == PHAssetResourceType.video || assetRes.type == PHAssetResourceType.pairedVideo &#123; resources = assetRes &#125;else&#123; print(&quot;失败&quot;) &#125; &#125; else &#123; // Fallback on earlier versions &#125; &#125; var fileName = &quot;&quot; guard let resource = resources ,resource.originalFilename.count &gt; 0 else&#123; continue &#125; fileName = resource.originalFilename print(fileName) // 获取视频地址成功 self.videoMessage(assetPH: asset, fileName: fileName,resource: resource) &#125; &#125; &#125; &#125; 获取信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 获取PHAsset 对象的信息 func videoMessage(assetPH: PHAsset,fileName: String,resource: PHAssetResource) &#123; let options = PHVideoRequestOptions() options.version = .current options.deliveryMode = .automatic options.isNetworkAccessAllowed = true var iconImage = UIImage() let option = PHImageRequestOptions() option.resizeMode = PHImageRequestOptionsResizeMode.fast // 获取视频对于的图片 PHImageManager.default().requestImage(for: assetPH, targetSize: CGSize(width: 116, height: 78), contentMode: PHImageContentMode.default, options: option) &#123; (image, info) in if let img = image &#123; iconImage = img &#125; &#125; PHImageManager.default().requestAVAsset(forVideo: assetPH, options: options) &#123; [weak self](asset, audioMix, info) in LOGGER.debug(asset) LOGGER.debug(audioMix) LOGGER.debug(info) guard let ass = asset else &#123; return &#125; guard let url = ass as? AVURLAsset else &#123; return &#125; var size : Float = 0 do &#123; let si = try url.url.resourceValues(forKeys: [URLResourceKey.fileSizeKey]) size = Float(si.fileSize ?? 0) / (1024.0*1024.0) &#125;catch &#123; &#125; // 计算时长 let time = ass.duration let seconds = ceil(Float(time.value)/Float(time.timescale)) let minute = String(format: &quot;%ld&quot;, Int(floor(seconds / 60))) let second = String(format: &quot;%.2ld&quot;, Int(seconds) % 60) let times = &quot;\(minute):\(second)&quot; //获取拍摄时间 let date = ass.creationDate?.dateValue let dataFormat = DateFormatter() dataFormat.dateFormat = &quot;yyyy:MM:dd HH:mm:ss&quot; let cDate = dataFormat.string(from: date ?? Date(timeIntervalSinceNow: 0)) // let name = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).first ?? &quot;&quot;// let format = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).last ?? &quot;&quot; let name = fileName.components(separatedBy: &quot;.&quot;).first ?? &quot;&quot; let format = fileName.components(separatedBy: &quot;.&quot;).last ?? &quot;&quot; let videoinfo = videoInfo(image: iconImage, name: name, time: times, urlStr: nil, length: times, selected: false, date: cDate, size: size, second: String(format: &quot;%.0f&quot;, seconds),format: format) self?.getVideo(asset: assetPH, fileName: fileName, resource: resource, info: videoinfo) // DispatchQueue.main.async &#123;// self?.videoArr.append(videoinfo)// self?._mainTableView.reloadData()// &#125; &#125; &#125; 将视频写入到本地，从本地读取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取视频 func getVideo(asset: PHAsset,fileName: String,resource: PHAssetResource,info: videoInfo) &#123; if #available(iOS 9.1, *) &#123; if asset.mediaType == PHAssetMediaType.video || asset.mediaSubtypes == PHAssetMediaSubtype.photoLive &#123; let pathMovieFile = NSTemporaryDirectory().appendingPathComponent(fileName) try? FileManager.default.removeItem(atPath: pathMovieFile) PHAssetResourceManager.default().writeData(for: resource, toFile: URL.init(fileURLWithPath: pathMovieFile), options: nil) &#123; [weak self](error) in guard error == nil else &#123; return &#125;// do &#123;//// let data = try Data.init(contentsOf: URL.init(fileURLWithPath: pathMovieFile))//// print(&quot;转data成功&quot;)// &#125;catch let error&#123;// print(error)// print(&quot;转data失败&quot;)// &#125; var video = info video.setUrl(url: pathMovieFile) // 获取到视频url后存入到视频信息中 // 刷新列表， 一定要在主线程中加入到数组，不然会出现崩溃 DispatchQueue.main.async &#123; self?.videoArr.append(video) self?._mainTableView.reloadData() &#125; &#125; &#125;else&#123; &#125; &#125; else &#123; // Fallback on earlier versions &#125; &#125; // 转成data let data : Data do &#123; data = try Data.init(contentsOf: URL.init(fileURLWithPath: path)) &#125;catch let error &#123; print(error) LOGGER.debug(&quot;filepath 转 data 失败&quot;) HUDUtilInstance.showHUD(message: &quot;获取视频失败&quot;) &#125; 最后注意在适合的地方删除本地的缓存]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 支持某个页面横竖屏切换与强制横屏]]></title>
    <url>%2F2018%2F08%2F16%2FSwift%20%E6%94%AF%E6%8C%81%E6%A8%AA%E7%AB%96%E5%B1%8F%E4%B8%8E%E5%BC%BA%E5%88%B6%E6%A8%AA%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[Demo地址 首先需要清晰几个概念 UIDeviceOrientation 设备的物理方向 UIDeviceOrientation即我们手持的移动设备的Orientation，是一个三围空间，有六个方向 12345678910111213141516public enum UIDeviceOrientation : Int &#123; case unknown case portrait // Device oriented vertically, home button on the bottom case portraitUpsideDown // Device oriented vertically, home button on the top case landscapeLeft // Device oriented horizontally, home button on the right case landscapeRight // Device oriented horizontally, home button on the left case faceUp // Device oriented flat, face up case faceDown // Device oriented flat, face down&#125; UIInterfaceOrientation 界面的显示方向 UIInterfaceOrientation即我们看到的视图的Orientation，可以理解为statusBar所在的方向，是一个二维空间，有四个方向 123456789101112public enum UIInterfaceOrientation : Int &#123; case unknown case portrait case portraitUpsideDown case landscapeLeft case landscapeRight&#125; 支持某个页面横竖屏切换项目要求是要某个界面能够横竖屏显示，其他界面要竖屏显示 1.打开 General 中的 Device orientation 中的 landscapeLeft 与 landscapeRight 2.在AppDelegate中设置app支持的方法这里要设置一个全局变量，判断支持的方向 123456789var blockRotation = Bool()func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; if blockRotation &#123; return .allButUpsideDown &#125; return .portrait &#125; 3.在需要支持横竖屏的控制器中1let appDelegate = UIApplication.shared.delegate as! AppDelegate 在viewDidLoad或viewWillAppear中 1234override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) appDelegate.blockRotation = true &#125; 在viewWillDisAppear中 1234567891011override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) appDelegate.blockRotation = false //判断退出时是否是横屏 if UIApplication.shared.statusBarOrientation.isLandscape &#123; //是横屏让变回竖屏 setNewOrientation(fullScreen: false) &#125; &#125; 退出时需要回到竖屏的状态 1234567891011121314151617//横竖屏 func setNewOrientation(fullScreen: Bool) &#123; if fullScreen &#123; //横屏 let resetOrientationTargert = NSNumber(integerLiteral: UIInterfaceOrientation.unknown.rawValue) UIDevice.current.setValue(resetOrientationTargert, forKey: &quot;orientation&quot;) let orientationTarget = NSNumber(integerLiteral: UIInterfaceOrientation.landscapeLeft.rawValue) UIDevice.current.setValue(orientationTarget, forKey: &quot;orientation&quot;) &#125;else &#123; //竖屏 let resetOrientationTargert = NSNumber(integerLiteral: UIInterfaceOrientation.unknown.rawValue) UIDevice.current.setValue(resetOrientationTargert, forKey: &quot;orientation&quot;) let orientationTarget = NSNumber(integerLiteral: UIInterfaceOrientation.portrait.rawValue) UIDevice.current.setValue(orientationTarget, forKey: &quot;orientation&quot;) &#125; &#125; 4.判断页面方向横竖屏这里已经实现了，难处理的是横竖屏后界面视图的适配用snapKit布局会方便很多，但有些布局，需要判断当前界面时竖屏还是横屏 12//statusBar的朝向UIApplication.shared.statusBarOrientation.isLandscape statusBarOrientation 有两个属性，isLandscape、isPortrait 用来判断是横屏还是竖屏，这是对页面的判断 在有弹出窗的时候，在窗口弹出时判断是横屏还是竖屏，分别做不同的布局 5.判断设备物理方便改变123456//注册通知 if !UIDevice.current.isGeneratingDeviceOrientationNotifications &#123; //生成通知 UIDevice.current.beginGeneratingDeviceOrientationNotifications() &#125; NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceOrientationChange(notification:)), name: NSNotification.Name.UIDeviceOrientationDidChange, object: nil) 实现通知的方法 12345678910111213141516171819202122232425262728293031323334@objc private func handleDeviceOrientationChange(notification: Notification) &#123; let orientation = UIDevice.current.orientation switch orientation &#123; case .portrait: /* iOS8之后,横屏UIScreen.main.bounds.width等于竖屏时的UIScreen.main.bounds.height let ScreenW = UIApplication.shared.statusBarOrientation.isLandscape ? UIScreen.main.bounds.size.height : UIScreen.main.bounds.size.width let ScreenH = UIApplication.shared.statusBarOrientation.isLandscape ? UIScreen.main.bounds.size.width : UIScreen.main.bounds.size.height ScreenW 记录的是屏幕短边的长度 ScreenH 记录的是屏幕长边的长度 */ showLabel.frame = CGRect(x: 0, y: 0, width: ScreenW, height: 20) case .landscapeLeft: showLabel.frame = CGRect(x: 0, y: 0, width: ScreenW, height: 20) case .landscapeRight: //横屏后做界面的调整的代码 showLabel.frame = CGRect(x: 200, y: 200, width: 80, height: 20) default: break &#125; &#125; 最后移除通知 12345deinit &#123; //移除通知 NotificationCenter.default.removeObserver(self) UIDevice.current.endGeneratingDeviceOrientationNotifications() &#125; 这里用了两个判断： 判断当前页面是横屏还是竖屏 UIApplication.shared.statusBarOrientation.isLandscape (页面方向) 判断当前手机发生了横屏切换还是竖屏切换： 通知的方法 let orientation =UIDevice.current.orientation （设备的方向） 在通知的方法里完成布局 项目中比demo中布局复杂，使用这两个判断结合的方式进行布局 强制横屏1.关闭 General 中的 Device orientation 中的 landscapeLeft 与 landscapeRight 2.在AppDelegate中设置app支持的方法这里要设置一个全局变量，判断支持的方向，这里支持一个方向 123456789var blockRotation = Bool()func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; if blockRotation &#123; return .landscapeLeft &#125; return .portrait &#125; 3. 强制横屏方法swift移除了NSInvocation, 只能桥接，需要创建桥接文件，注意桥接文件路径 123456789101112131415161718192021222324252627282930313233// h文件#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface DeviceTool : NSObject+ (void)interfaceOrientation:(UIInterfaceOrientation )orientation;@end//m文件#import &quot;DeviceTool.h&quot;@interface DeviceTool ()@end@implementation DeviceTool+ (void)interfaceOrientation:(UIInterfaceOrientation)orientation&#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = orientation; // 从2开始是因为0 1 两个参数已经被selector和target占用 [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125;@end 4.实现横屏实现的是强制转landscapeLeft方向，与appDelegate中支持的方向一致，这样是否打开系统竖排方向锁定不影响强转方向 1234567891011@objc func buttonClick(btn:UIButton) &#123; btn.isSelected = !btn.isSelected if btn.isSelected &#123; appDelegate.blockRotation = true DeviceTool.interfaceOrientation(.landscapeLeft) &#125;else&#123; appDelegate.blockRotation = false DeviceTool.interfaceOrientation(.portrait) &#125; &#125; 附上Demo]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取String中的url并用其他颜色显示]]></title>
    <url>%2F2018%2F08%2F09%2FiOS%20%E8%8E%B7%E5%8F%96String%E4%B8%AD%E7%9A%84url%E5%B9%B6%E7%94%A8%E5%85%B6%E4%BB%96%E9%A2%9C%E8%89%B2%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[这里用textView显示带url的String1234567891011fileprivate let detailText = UITextView().then &#123; (textview)in textview.font = UIFont.systemFont(ofSize:14) textview.textColor = UIColor(hexString:&quot;#333333&quot;) textview.isEditable =false; //必须禁止输入，否则点击将弹出输入键盘 textview.isScrollEnabled =false;&#125; 用这个方法获取url,获取url的数组123456789101112131415161718192021222324private func getUrls(str:String) -&gt; [String] &#123; varurls = [String]() // 创建一个正则表达式对象 do&#123; let dataDetector = try NSDataDetector(types:NSTextCheckingTypes(NSTextCheckingResult.CheckingType.link.rawValue)) // 匹配字符串，返回结果集 let res = dataDetector.matches(in: str,options:NSRegularExpression.MatchingOptions(rawValue:0),range:NSMakeRange(0, str.count)) // 取出结果 for checkingRes in res &#123; urls.append((str as NSString).substring(with: checkingRes.range)) &#125; &#125; catch&#123; print(error) &#125; returnurls &#125; 获取url数组12345678910111213141516171819202122232425262728293031let arr =self.getUrls(str: state.detail)let attrubuteStr = NSMutableAttributedString(string: state.detail)if arr.count &gt;0&#123; for i in arr &#123; let nsString = NSString(string: state.detail) let bigRange = nsString.range(of: state.detail) let range = nsString.range(of: i) attrubuteStr.addAttribute(NSAttributedStringKey.font, value: UIFont.systemFont(ofSize:14), range: bigRange) attrubuteStr.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor(hexString:&quot;#286efa&quot;)!, range: range) attrubuteStr.addAttribute(NSAttributedStringKey.link, value: i, range: range) &#125;&#125;else&#123; let nsString = NSString(string: state.detail) let bigRange = nsString.range(of: state.detail) attrubuteStr.addAttribute(NSAttributedStringKey.font, value: UIFont.systemFont(ofSize:14), range: bigRange)&#125;self.detailText.attributedText = attrubuteStr 最后实现textView的代理方法，点击url触发事件1234func textView(_textView:UITextView, shouldInteractWith URL:URL, in characterRange:NSRange, interaction:UITextItemInteraction) -&gt;Bool&#123; self.navigatorService?.navigatorSubject.onNext(NavigatorItem.WebPage(&quot;&quot;,&quot;\(URL)&quot;)) return false&#125;]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 蓝牙键盘、鼠标断开连接之后无法重新连接的解决办法]]></title>
    <url>%2F2018%2F08%2F08%2Fmac%20%E8%93%9D%E7%89%99%E9%94%AE%E7%9B%98%E3%80%81%E9%BC%A0%E6%A0%87%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[网上找的方法，记录一下find ~/Library -name com.apple.Bluetooth.*.plist -exec rm{}\; sudo rm /Library/Preferences/com.apple.Bluetooth.plist 重启之后重新配置一下蓝牙设备。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
