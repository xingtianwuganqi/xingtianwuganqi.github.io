<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift 支持某个页面横竖屏切换与强制横屏]]></title>
    <url>%2F2018%2F08%2F16%2FSwift%20%E6%94%AF%E6%8C%81%E6%A8%AA%E7%AB%96%E5%B1%8F%E4%B8%8E%E5%BC%BA%E5%88%B6%E6%A8%AA%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[Swift 支持某个页面横竖屏切换与强制横屏Demo地址 首先需要清晰几个概念 UIDeviceOrientation 设备的物理方向 UIDeviceOrientation即我们手持的移动设备的Orientation，是一个三围空间，有六个方向 12345678910111213141516public enum UIDeviceOrientation : Int &#123; case unknown case portrait // Device oriented vertically, home button on the bottom case portraitUpsideDown // Device oriented vertically, home button on the top case landscapeLeft // Device oriented horizontally, home button on the right case landscapeRight // Device oriented horizontally, home button on the left case faceUp // Device oriented flat, face up case faceDown // Device oriented flat, face down&#125; UIInterfaceOrientation 界面的显示方向 UIInterfaceOrientation即我们看到的视图的Orientation，可以理解为statusBar所在的方向，是一个二维空间，有四个方向 123456789101112public enum UIInterfaceOrientation : Int &#123; case unknown case portrait case portraitUpsideDown case landscapeLeft case landscapeRight&#125; 支持某个页面横竖屏切换项目要求是要某个界面能够横竖屏显示，其他界面要竖屏显示 1.打开 General 中的 Device orientation 中的 landscapeLeft 与 landscapeRight 2.在AppDelegate中设置app支持的方法这里要设置一个全局变量，判断支持的方向 123456789var blockRotation = Bool()func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; if blockRotation &#123; return .allButUpsideDown &#125; return .portrait &#125; 3.在需要支持横竖屏的控制器中1let appDelegate = UIApplication.shared.delegate as! AppDelegate 在viewDidLoad或viewWillAppear中 1234override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) appDelegate.blockRotation = true &#125; 在viewWillDisAppear中 1234567891011override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) appDelegate.blockRotation = false //判断退出时是否是横屏 if UIApplication.shared.statusBarOrientation.isLandscape &#123; //是横屏让变回竖屏 setNewOrientation(fullScreen: false) &#125; &#125; 退出时需要回到竖屏的状态 1234567891011121314151617//横竖屏 func setNewOrientation(fullScreen: Bool) &#123; if fullScreen &#123; //横屏 let resetOrientationTargert = NSNumber(integerLiteral: UIInterfaceOrientation.unknown.rawValue) UIDevice.current.setValue(resetOrientationTargert, forKey: &quot;orientation&quot;) let orientationTarget = NSNumber(integerLiteral: UIInterfaceOrientation.landscapeLeft.rawValue) UIDevice.current.setValue(orientationTarget, forKey: &quot;orientation&quot;) &#125;else &#123; //竖屏 let resetOrientationTargert = NSNumber(integerLiteral: UIInterfaceOrientation.unknown.rawValue) UIDevice.current.setValue(resetOrientationTargert, forKey: &quot;orientation&quot;) let orientationTarget = NSNumber(integerLiteral: UIInterfaceOrientation.portrait.rawValue) UIDevice.current.setValue(orientationTarget, forKey: &quot;orientation&quot;) &#125; &#125; 4.判断页面方向横竖屏这里已经实现了，难处理的是横竖屏后界面视图的适配用snapKit布局会方便很多，但有些布局，需要判断当前界面时竖屏还是横屏 12//statusBar的朝向UIApplication.shared.statusBarOrientation.isLandscape statusBarOrientation 有两个属性，isLandscape、isPortrait 用来判断是横屏还是竖屏，这是对页面的判断 在有弹出窗的时候，在窗口弹出时判断是横屏还是竖屏，分别做不同的布局 5.判断设备物理方便改变123456//注册通知 if !UIDevice.current.isGeneratingDeviceOrientationNotifications &#123; //生成通知 UIDevice.current.beginGeneratingDeviceOrientationNotifications() &#125; NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceOrientationChange(notification:)), name: NSNotification.Name.UIDeviceOrientationDidChange, object: nil) 实现通知的方法 12345678910111213141516171819202122232425262728293031323334@objc private func handleDeviceOrientationChange(notification: Notification) &#123; let orientation = UIDevice.current.orientation switch orientation &#123; case .portrait: /* iOS8之后,横屏UIScreen.main.bounds.width等于竖屏时的UIScreen.main.bounds.height let ScreenW = UIApplication.shared.statusBarOrientation.isLandscape ? UIScreen.main.bounds.size.height : UIScreen.main.bounds.size.width let ScreenH = UIApplication.shared.statusBarOrientation.isLandscape ? UIScreen.main.bounds.size.width : UIScreen.main.bounds.size.height ScreenW 记录的是屏幕短边的长度 ScreenH 记录的是屏幕长边的长度 */ showLabel.frame = CGRect(x: 0, y: 0, width: ScreenW, height: 20) case .landscapeLeft: showLabel.frame = CGRect(x: 0, y: 0, width: ScreenW, height: 20) case .landscapeRight: //横屏后做界面的调整的代码 showLabel.frame = CGRect(x: 200, y: 200, width: 80, height: 20) default: break &#125; &#125; 最后移除通知 12345deinit &#123; //移除通知 NotificationCenter.default.removeObserver(self) UIDevice.current.endGeneratingDeviceOrientationNotifications() &#125; 这里用了两个判断： 判断当前页面是横屏还是竖屏 UIApplication.shared.statusBarOrientation.isLandscape (页面方向) 判断当前手机发生了横屏切换还是竖屏切换： 通知的方法 let orientation =UIDevice.current.orientation （设备的方向） 在通知的方法里完成布局 项目中比demo中布局复杂，使用这两个判断结合的方式进行布局 强制横屏1.关闭 General 中的 Device orientation 中的 landscapeLeft 与 landscapeRight 2.在AppDelegate中设置app支持的方法这里要设置一个全局变量，判断支持的方向，这里支持一个方向 123456789var blockRotation = Bool()func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; if blockRotation &#123; return .landscapeLeft &#125; return .portrait &#125; 3. 强制横屏方法swift移除了NSInvocation, 只能桥接，需要创建桥接文件，注意桥接文件路径 123456789101112131415161718192021222324252627282930313233// h文件#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface DeviceTool : NSObject+ (void)interfaceOrientation:(UIInterfaceOrientation )orientation;@end//m文件#import &quot;DeviceTool.h&quot;@interface DeviceTool ()@end@implementation DeviceTool+ (void)interfaceOrientation:(UIInterfaceOrientation)orientation&#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = orientation; // 从2开始是因为0 1 两个参数已经被selector和target占用 [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125;@end 4.实现横屏实现的是强制转landscapeLeft方向，与appDelegate中支持的方向一致，这样是否打开系统竖排方向锁定不影响强转方向 1234567891011@objc func buttonClick(btn:UIButton) &#123; btn.isSelected = !btn.isSelected if btn.isSelected &#123; appDelegate.blockRotation = true DeviceTool.interfaceOrientation(.landscapeLeft) &#125;else&#123; appDelegate.blockRotation = false DeviceTool.interfaceOrientation(.portrait) &#125; &#125; 附上Demo]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取String中的url并用其他颜色显示]]></title>
    <url>%2F2018%2F08%2F09%2FiOS%20%E8%8E%B7%E5%8F%96String%E4%B8%AD%E7%9A%84url%E5%B9%B6%E7%94%A8%E5%85%B6%E4%BB%96%E9%A2%9C%E8%89%B2%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[iOS 获取String中的url并用其他颜色显示这里用textView显示带url的String1234567891011fileprivate let detailText = UITextView().then &#123; (textview)in textview.font = UIFont.systemFont(ofSize:14) textview.textColor = UIColor(hexString:&quot;#333333&quot;) textview.isEditable =false; //必须禁止输入，否则点击将弹出输入键盘 textview.isScrollEnabled =false;&#125; 用这个方法获取url,获取url的数组123456789101112131415161718192021222324private func getUrls(str:String) -&gt; [String] &#123; varurls = [String]() // 创建一个正则表达式对象 do&#123; let dataDetector = try NSDataDetector(types:NSTextCheckingTypes(NSTextCheckingResult.CheckingType.link.rawValue)) // 匹配字符串，返回结果集 let res = dataDetector.matches(in: str,options:NSRegularExpression.MatchingOptions(rawValue:0),range:NSMakeRange(0, str.count)) // 取出结果 for checkingRes in res &#123; urls.append((str as NSString).substring(with: checkingRes.range)) &#125; &#125; catch&#123; print(error) &#125; returnurls &#125; 获取url数组12345678910111213141516171819202122232425262728293031let arr =self.getUrls(str: state.detail)let attrubuteStr = NSMutableAttributedString(string: state.detail)if arr.count &gt;0&#123; for i in arr &#123; let nsString = NSString(string: state.detail) let bigRange = nsString.range(of: state.detail) let range = nsString.range(of: i) attrubuteStr.addAttribute(NSAttributedStringKey.font, value: UIFont.systemFont(ofSize:14), range: bigRange) attrubuteStr.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor(hexString:&quot;#286efa&quot;)!, range: range) attrubuteStr.addAttribute(NSAttributedStringKey.link, value: i, range: range) &#125;&#125;else&#123; let nsString = NSString(string: state.detail) let bigRange = nsString.range(of: state.detail) attrubuteStr.addAttribute(NSAttributedStringKey.font, value: UIFont.systemFont(ofSize:14), range: bigRange)&#125;self.detailText.attributedText = attrubuteStr 最后实现textView的代理方法，点击url触发事件1234func textView(_textView:UITextView, shouldInteractWith URL:URL, in characterRange:NSRange, interaction:UITextItemInteraction) -&gt;Bool&#123; self.navigatorService?.navigatorSubject.onNext(NavigatorItem.WebPage(&quot;&quot;,&quot;\(URL)&quot;)) return false&#125;]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 蓝牙键盘、鼠标断开连接之后无法重新连接的解决办法]]></title>
    <url>%2F2018%2F08%2F08%2Fmac%20%E8%93%9D%E7%89%99%E9%94%AE%E7%9B%98%E3%80%81%E9%BC%A0%E6%A0%87%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[mac 蓝牙键盘、鼠标断开连接之后无法重新连接的解决办法网上找的方法，记录一下find ~/Library -name com.apple.Bluetooth.*.plist -exec rm{}\;sudo rm /Library/Preferences/com.apple.Bluetooth.plist 重启之后重新配置一下蓝牙设备。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
