<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 获取相册中的视频列表]]></title>
    <url>%2F2019%2F08%2F07%2FiOS%20%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%86%8C%E4%B8%AD%E7%9A%84%E8%A7%86%E9%A2%91%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[iOS 获取相册中的视频列表获取相册中的视频文件123456789101112131415161718192021222324func getAllvideo() &#123; let cameraRolls = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumVideos, options: nil) print(cameraRolls) guard cameraRolls.count &gt; 0 else &#123; return &#125; for i in 0 ..&lt; cameraRolls.count &#123; let albumCollection = cameraRolls[i] // 获取相簿(albumCollection)下所有PHAsset对象并存储在集合albumAssets中 LOGGER.debug(albumCollection.localizedTitle) let albumAssets = PHAsset.fetchAssets(in: albumCollection, options: nil) for i in 0 ..&lt; albumAssets.count &#123; let asset = albumAssets[i] let filetype = asset.mediaType if filetype == PHAssetMediaType.video &#123; videoMessage(asset: asset,count: albumAssets.count) &#125; continue &#125; &#125; &#125; 获取视频信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 获取PHAsset 对象的信息 func videoMessage(asset: PHAsset , count: Int) &#123; let options = PHVideoRequestOptions() options.version = .current options.deliveryMode = .automatic options.isNetworkAccessAllowed = true // 获取iCloud 中的视频 var iconImage = UIImage() let option = PHImageRequestOptions() option.resizeMode = PHImageRequestOptionsResizeMode.fast // 获取视频对于的图片 PHImageManager.default().requestImage(for: asset, targetSize: CGSize(width: 116, height: 78), contentMode: PHImageContentMode.default, options: option) &#123; (image, info) in if let img = image &#123; iconImage = img &#125; &#125; PHImageManager.default().requestAVAsset(forVideo: asset, options: options) &#123; [weak self](asset, audioMix, info) in LOGGER.debug(asset) LOGGER.debug(audioMix) LOGGER.debug(info) guard let ass = asset else &#123; return &#125; guard let url = ass as? AVURLAsset else &#123; return &#125; var size : Float = 0 do &#123; let si = try url.url.resourceValues(forKeys: [URLResourceKey.fileSizeKey]) size = Float(si.fileSize ?? 0) / (1024.0*1024.0) &#125;catch &#123; &#125; // 计算时长 let time = ass.duration let seconds = ceil(Float(time.value)/Float(time.timescale)) let minute = String(format: &quot;%ld&quot;, Int(floor(seconds / 60))) let second = String(format: &quot;%.2ld&quot;, Int(seconds) % 60) let times = &quot;\(minute):\(second)&quot; //获取拍摄时间 let date = ass.creationDate?.dateValue let dataFormat = DateFormatter() dataFormat.dateFormat = &quot;yyyy:MM:dd HH:mm:ss&quot; let cDate = dataFormat.string(from: date ?? Date(timeIntervalSinceNow: 0)) let name = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).first ?? &quot;&quot; let format = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).last ?? &quot;&quot; let videoinfo = videoInfo(image: iconImage, name: name, time: times, urlStr: url.url.absoluteString, length: times, selected: false, date: cDate, size: size, second: String(format: &quot;%.0f&quot;, seconds),format: format) // 一定要在主线程中加入到数组，不然会出现崩溃 DispatchQueue.main.async &#123; self?.videoArr.append(videoinfo) self?._mainTableView.reloadData() &#125; &#125; &#125; 在测试中，上述方法可以获取相册视频的文件地址，但是在部分手机上，将文件地址转换成data上传到服务器时出错了1234567891011121314151617181920let data : Data do &#123; data = try Data.init(contentsOf: URL.init(string: path)) manager?.put(data, key: key, token: token, complete: &#123; [weak self](info, key, resp) in &#125;, option: options) &#125;catch let error &#123; // 这里报错，打印出来是 /* Error Domain=NSCocoaErrorDomain Code=257 &quot;The file “IMG_0288.MP4” couldn’t be\ opened because you don’t have permission to view it.&quot; UserInfo= &#123;NSFilePath=/var/mobile/Media/DCIM/100APPLE/IMG_0288.MP4, NSUnderlyingError=0x17d761b0 &#123;Error Domain=NSPOSIXErrorDomain Code=1 &quot;Operation not permitted&quot;&#125;&#125; */ print(error) LOGGER.debug(&quot;filepath 转 data 失败&quot;) HUDUtilInstance.showHUD(message: &quot;获取视频失败&quot;) &#125; 通过查资料https://io.upyun.com/2016/03/23/the-real-files-in-alasset-and-phasset/代码调整为 获取相册中的视频文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func getAllvideo() &#123; let cameraRolls = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumVideos, options: nil) print(cameraRolls) guard cameraRolls.count &gt; 0 else &#123; return &#125; for i in 0 ..&lt; cameraRolls.count &#123; let albumCollection = cameraRolls[i] // 获取相簿(albumCollection)下所有PHAsset对象并存储在集合albumAssets中 LOGGER.debug(albumCollection.localizedTitle) let albumAssets = PHAsset.fetchAssets(in: albumCollection, options: nil) for i in 0 ..&lt; albumAssets.count &#123; let asset = albumAssets[i] let filetype = asset.mediaType // if filetype == PHAssetMediaType.video &#123; // videoMessage(asset: asset,count: albumAssets.count) // &#125; if filetype == PHAssetMediaType.video &#123; // 通过asset 获取视频 let assetResources = PHAssetResource.assetResources(for: asset) var resources : PHAssetResource? for assetRes in assetResources &#123; if #available(iOS 9.1, *) &#123; if assetRes.type == PHAssetResourceType.video || assetRes.type == PHAssetResourceType.pairedVideo &#123; resources = assetRes &#125;else&#123; print(&quot;失败&quot;) &#125; &#125; else &#123; // Fallback on earlier versions &#125; &#125; var fileName = &quot;&quot; guard let resource = resources ,resource.originalFilename.count &gt; 0 else&#123; continue &#125; fileName = resource.originalFilename print(fileName) // 获取视频地址成功 self.videoMessage(assetPH: asset, fileName: fileName,resource: resource) &#125; &#125; &#125; &#125; 获取信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 获取PHAsset 对象的信息 func videoMessage(assetPH: PHAsset,fileName: String,resource: PHAssetResource) &#123; let options = PHVideoRequestOptions() options.version = .current options.deliveryMode = .automatic options.isNetworkAccessAllowed = true var iconImage = UIImage() let option = PHImageRequestOptions() option.resizeMode = PHImageRequestOptionsResizeMode.fast // 获取视频对于的图片 PHImageManager.default().requestImage(for: assetPH, targetSize: CGSize(width: 116, height: 78), contentMode: PHImageContentMode.default, options: option) &#123; (image, info) in if let img = image &#123; iconImage = img &#125; &#125; PHImageManager.default().requestAVAsset(forVideo: assetPH, options: options) &#123; [weak self](asset, audioMix, info) in LOGGER.debug(asset) LOGGER.debug(audioMix) LOGGER.debug(info) guard let ass = asset else &#123; return &#125; guard let url = ass as? AVURLAsset else &#123; return &#125; var size : Float = 0 do &#123; let si = try url.url.resourceValues(forKeys: [URLResourceKey.fileSizeKey]) size = Float(si.fileSize ?? 0) / (1024.0*1024.0) &#125;catch &#123; &#125; // 计算时长 let time = ass.duration let seconds = ceil(Float(time.value)/Float(time.timescale)) let minute = String(format: &quot;%ld&quot;, Int(floor(seconds / 60))) let second = String(format: &quot;%.2ld&quot;, Int(seconds) % 60) let times = &quot;\(minute):\(second)&quot; //获取拍摄时间 let date = ass.creationDate?.dateValue let dataFormat = DateFormatter() dataFormat.dateFormat = &quot;yyyy:MM:dd HH:mm:ss&quot; let cDate = dataFormat.string(from: date ?? Date(timeIntervalSinceNow: 0)) // let name = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).first ?? &quot;&quot;// let format = url.url.absoluteString.components(separatedBy: &quot;/&quot;).last?.components(separatedBy: &quot;.&quot;).last ?? &quot;&quot; let name = fileName.components(separatedBy: &quot;.&quot;).first ?? &quot;&quot; let format = fileName.components(separatedBy: &quot;.&quot;).last ?? &quot;&quot; let videoinfo = videoInfo(image: iconImage, name: name, time: times, urlStr: nil, length: times, selected: false, date: cDate, size: size, second: String(format: &quot;%.0f&quot;, seconds),format: format) self?.getVideo(asset: assetPH, fileName: fileName, resource: resource, info: videoinfo) // DispatchQueue.main.async &#123;// self?.videoArr.append(videoinfo)// self?._mainTableView.reloadData()// &#125; &#125; &#125; 将视频写入到本地，从本地读取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取视频 func getVideo(asset: PHAsset,fileName: String,resource: PHAssetResource,info: videoInfo) &#123; if #available(iOS 9.1, *) &#123; if asset.mediaType == PHAssetMediaType.video || asset.mediaSubtypes == PHAssetMediaSubtype.photoLive &#123; let pathMovieFile = NSTemporaryDirectory().appendingPathComponent(fileName) try? FileManager.default.removeItem(atPath: pathMovieFile) PHAssetResourceManager.default().writeData(for: resource, toFile: URL.init(fileURLWithPath: pathMovieFile), options: nil) &#123; [weak self](error) in guard error == nil else &#123; return &#125;// do &#123;//// let data = try Data.init(contentsOf: URL.init(fileURLWithPath: pathMovieFile))//// print(&quot;转data成功&quot;)// &#125;catch let error&#123;// print(error)// print(&quot;转data失败&quot;)// &#125; var video = info video.setUrl(url: pathMovieFile) // 获取到视频url后存入到视频信息中 // 刷新列表， 一定要在主线程中加入到数组，不然会出现崩溃 DispatchQueue.main.async &#123; self?.videoArr.append(video) self?._mainTableView.reloadData() &#125; &#125; &#125;else&#123; &#125; &#125; else &#123; // Fallback on earlier versions &#125; &#125; // 转成data let data : Data do &#123; data = try Data.init(contentsOf: URL.init(fileURLWithPath: path)) &#125;catch let error &#123; print(error) LOGGER.debug(&quot;filepath 转 data 失败&quot;) HUDUtilInstance.showHUD(message: &quot;获取视频失败&quot;) &#125; 最后注意在适合的地方删除本地的缓存]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 支持某个页面横竖屏切换与强制横屏]]></title>
    <url>%2F2018%2F08%2F16%2FSwift%20%E6%94%AF%E6%8C%81%E6%A8%AA%E7%AB%96%E5%B1%8F%E4%B8%8E%E5%BC%BA%E5%88%B6%E6%A8%AA%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[Swift 支持某个页面横竖屏切换与强制横屏Demo地址 首先需要清晰几个概念 UIDeviceOrientation 设备的物理方向 UIDeviceOrientation即我们手持的移动设备的Orientation，是一个三围空间，有六个方向 12345678910111213141516public enum UIDeviceOrientation : Int &#123; case unknown case portrait // Device oriented vertically, home button on the bottom case portraitUpsideDown // Device oriented vertically, home button on the top case landscapeLeft // Device oriented horizontally, home button on the right case landscapeRight // Device oriented horizontally, home button on the left case faceUp // Device oriented flat, face up case faceDown // Device oriented flat, face down&#125; UIInterfaceOrientation 界面的显示方向 UIInterfaceOrientation即我们看到的视图的Orientation，可以理解为statusBar所在的方向，是一个二维空间，有四个方向 123456789101112public enum UIInterfaceOrientation : Int &#123; case unknown case portrait case portraitUpsideDown case landscapeLeft case landscapeRight&#125; 支持某个页面横竖屏切换项目要求是要某个界面能够横竖屏显示，其他界面要竖屏显示 1.打开 General 中的 Device orientation 中的 landscapeLeft 与 landscapeRight 2.在AppDelegate中设置app支持的方法这里要设置一个全局变量，判断支持的方向 123456789var blockRotation = Bool()func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; if blockRotation &#123; return .allButUpsideDown &#125; return .portrait &#125; 3.在需要支持横竖屏的控制器中1let appDelegate = UIApplication.shared.delegate as! AppDelegate 在viewDidLoad或viewWillAppear中 1234override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) appDelegate.blockRotation = true &#125; 在viewWillDisAppear中 1234567891011override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) appDelegate.blockRotation = false //判断退出时是否是横屏 if UIApplication.shared.statusBarOrientation.isLandscape &#123; //是横屏让变回竖屏 setNewOrientation(fullScreen: false) &#125; &#125; 退出时需要回到竖屏的状态 1234567891011121314151617//横竖屏 func setNewOrientation(fullScreen: Bool) &#123; if fullScreen &#123; //横屏 let resetOrientationTargert = NSNumber(integerLiteral: UIInterfaceOrientation.unknown.rawValue) UIDevice.current.setValue(resetOrientationTargert, forKey: &quot;orientation&quot;) let orientationTarget = NSNumber(integerLiteral: UIInterfaceOrientation.landscapeLeft.rawValue) UIDevice.current.setValue(orientationTarget, forKey: &quot;orientation&quot;) &#125;else &#123; //竖屏 let resetOrientationTargert = NSNumber(integerLiteral: UIInterfaceOrientation.unknown.rawValue) UIDevice.current.setValue(resetOrientationTargert, forKey: &quot;orientation&quot;) let orientationTarget = NSNumber(integerLiteral: UIInterfaceOrientation.portrait.rawValue) UIDevice.current.setValue(orientationTarget, forKey: &quot;orientation&quot;) &#125; &#125; 4.判断页面方向横竖屏这里已经实现了，难处理的是横竖屏后界面视图的适配用snapKit布局会方便很多，但有些布局，需要判断当前界面时竖屏还是横屏 12//statusBar的朝向UIApplication.shared.statusBarOrientation.isLandscape statusBarOrientation 有两个属性，isLandscape、isPortrait 用来判断是横屏还是竖屏，这是对页面的判断 在有弹出窗的时候，在窗口弹出时判断是横屏还是竖屏，分别做不同的布局 5.判断设备物理方便改变123456//注册通知 if !UIDevice.current.isGeneratingDeviceOrientationNotifications &#123; //生成通知 UIDevice.current.beginGeneratingDeviceOrientationNotifications() &#125; NotificationCenter.default.addObserver(self, selector: #selector(handleDeviceOrientationChange(notification:)), name: NSNotification.Name.UIDeviceOrientationDidChange, object: nil) 实现通知的方法 12345678910111213141516171819202122232425262728293031323334@objc private func handleDeviceOrientationChange(notification: Notification) &#123; let orientation = UIDevice.current.orientation switch orientation &#123; case .portrait: /* iOS8之后,横屏UIScreen.main.bounds.width等于竖屏时的UIScreen.main.bounds.height let ScreenW = UIApplication.shared.statusBarOrientation.isLandscape ? UIScreen.main.bounds.size.height : UIScreen.main.bounds.size.width let ScreenH = UIApplication.shared.statusBarOrientation.isLandscape ? UIScreen.main.bounds.size.width : UIScreen.main.bounds.size.height ScreenW 记录的是屏幕短边的长度 ScreenH 记录的是屏幕长边的长度 */ showLabel.frame = CGRect(x: 0, y: 0, width: ScreenW, height: 20) case .landscapeLeft: showLabel.frame = CGRect(x: 0, y: 0, width: ScreenW, height: 20) case .landscapeRight: //横屏后做界面的调整的代码 showLabel.frame = CGRect(x: 200, y: 200, width: 80, height: 20) default: break &#125; &#125; 最后移除通知 12345deinit &#123; //移除通知 NotificationCenter.default.removeObserver(self) UIDevice.current.endGeneratingDeviceOrientationNotifications() &#125; 这里用了两个判断： 判断当前页面是横屏还是竖屏 UIApplication.shared.statusBarOrientation.isLandscape (页面方向) 判断当前手机发生了横屏切换还是竖屏切换： 通知的方法 let orientation =UIDevice.current.orientation （设备的方向） 在通知的方法里完成布局 项目中比demo中布局复杂，使用这两个判断结合的方式进行布局 强制横屏1.关闭 General 中的 Device orientation 中的 landscapeLeft 与 landscapeRight 2.在AppDelegate中设置app支持的方法这里要设置一个全局变量，判断支持的方向，这里支持一个方向 123456789var blockRotation = Bool()func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; if blockRotation &#123; return .landscapeLeft &#125; return .portrait &#125; 3. 强制横屏方法swift移除了NSInvocation, 只能桥接，需要创建桥接文件，注意桥接文件路径 123456789101112131415161718192021222324252627282930313233// h文件#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface DeviceTool : NSObject+ (void)interfaceOrientation:(UIInterfaceOrientation )orientation;@end//m文件#import &quot;DeviceTool.h&quot;@interface DeviceTool ()@end@implementation DeviceTool+ (void)interfaceOrientation:(UIInterfaceOrientation)orientation&#123; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) &#123; SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]]; [invocation setSelector:selector]; [invocation setTarget:[UIDevice currentDevice]]; int val = orientation; // 从2开始是因为0 1 两个参数已经被selector和target占用 [invocation setArgument:&amp;val atIndex:2]; [invocation invoke]; &#125;&#125;@end 4.实现横屏实现的是强制转landscapeLeft方向，与appDelegate中支持的方向一致，这样是否打开系统竖排方向锁定不影响强转方向 1234567891011@objc func buttonClick(btn:UIButton) &#123; btn.isSelected = !btn.isSelected if btn.isSelected &#123; appDelegate.blockRotation = true DeviceTool.interfaceOrientation(.landscapeLeft) &#125;else&#123; appDelegate.blockRotation = false DeviceTool.interfaceOrientation(.portrait) &#125; &#125; 附上Demo]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取String中的url并用其他颜色显示]]></title>
    <url>%2F2018%2F08%2F09%2FiOS%20%E8%8E%B7%E5%8F%96String%E4%B8%AD%E7%9A%84url%E5%B9%B6%E7%94%A8%E5%85%B6%E4%BB%96%E9%A2%9C%E8%89%B2%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[iOS 获取String中的url并用其他颜色显示这里用textView显示带url的String1234567891011fileprivate let detailText = UITextView().then &#123; (textview)in textview.font = UIFont.systemFont(ofSize:14) textview.textColor = UIColor(hexString:&quot;#333333&quot;) textview.isEditable =false; //必须禁止输入，否则点击将弹出输入键盘 textview.isScrollEnabled =false;&#125; 用这个方法获取url,获取url的数组123456789101112131415161718192021222324private func getUrls(str:String) -&gt; [String] &#123; varurls = [String]() // 创建一个正则表达式对象 do&#123; let dataDetector = try NSDataDetector(types:NSTextCheckingTypes(NSTextCheckingResult.CheckingType.link.rawValue)) // 匹配字符串，返回结果集 let res = dataDetector.matches(in: str,options:NSRegularExpression.MatchingOptions(rawValue:0),range:NSMakeRange(0, str.count)) // 取出结果 for checkingRes in res &#123; urls.append((str as NSString).substring(with: checkingRes.range)) &#125; &#125; catch&#123; print(error) &#125; returnurls &#125; 获取url数组12345678910111213141516171819202122232425262728293031let arr =self.getUrls(str: state.detail)let attrubuteStr = NSMutableAttributedString(string: state.detail)if arr.count &gt;0&#123; for i in arr &#123; let nsString = NSString(string: state.detail) let bigRange = nsString.range(of: state.detail) let range = nsString.range(of: i) attrubuteStr.addAttribute(NSAttributedStringKey.font, value: UIFont.systemFont(ofSize:14), range: bigRange) attrubuteStr.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor(hexString:&quot;#286efa&quot;)!, range: range) attrubuteStr.addAttribute(NSAttributedStringKey.link, value: i, range: range) &#125;&#125;else&#123; let nsString = NSString(string: state.detail) let bigRange = nsString.range(of: state.detail) attrubuteStr.addAttribute(NSAttributedStringKey.font, value: UIFont.systemFont(ofSize:14), range: bigRange)&#125;self.detailText.attributedText = attrubuteStr 最后实现textView的代理方法，点击url触发事件1234func textView(_textView:UITextView, shouldInteractWith URL:URL, in characterRange:NSRange, interaction:UITextItemInteraction) -&gt;Bool&#123; self.navigatorService?.navigatorSubject.onNext(NavigatorItem.WebPage(&quot;&quot;,&quot;\(URL)&quot;)) return false&#125;]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 蓝牙键盘、鼠标断开连接之后无法重新连接的解决办法]]></title>
    <url>%2F2018%2F08%2F08%2Fmac%20%E8%93%9D%E7%89%99%E9%94%AE%E7%9B%98%E3%80%81%E9%BC%A0%E6%A0%87%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E4%B9%8B%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[mac 蓝牙键盘、鼠标断开连接之后无法重新连接的解决办法网上找的方法，记录一下find ~/Library -name com.apple.Bluetooth.*.plist -exec rm{}\;sudo rm /Library/Preferences/com.apple.Bluetooth.plist 重启之后重新配置一下蓝牙设备。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
